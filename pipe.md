# pipe パイプを生成する

## 書式
```c
#include <unistd.h>

int pipe(int fd[2]);
```

## 引数
- `fd`<br>パイプの両端のファイル記述子２つを格納する配列

## 戻り値
- `0`<br>パイプの作成に成功
- `-1`<br>エラーが発生

## 解説
`pipe`を呼び出すとパイプが作成されて、パイプの読み出し側と書き込み側それぞれにファイル記述子が割り当てられます。
読み出し側のファイル記述子は、引数`fd`が示す配列の`fd[0]`に、書き込み側のファイル記述子は`fd[1]`に代入されます。

プログラム側では、あらかじめパイプのファイル記述子を格納するための要素数2の配列（`int fd[2]`）を用意し、
その配列名`fd`を引数にして`pipe`を呼び出すようにします。
`open`とは異なり、`pipe`の戻り値はファイル記述子ではなく、エラーかどうかを示す値になります。

パイプの書き込み側にデータを書き込むと、まったく同じデータがパイプの読み出し側から読み出せます。
パイプを作成した後で`fork`を実行して子プロセスを作成すると、パイプのファイル記述子は親と子のプロセス間で共有された状態になります。
ここで、たとえば子プロセスがパイプの書き込み側に書き込むと、親プロセスはそのデータをパイプの読み出し側から読み込むことができます。
このように、`pipe`は通常`fork`とともに用いられ、パイプによるプロセス間通信（interprocess communication、IPC）が実現されています。

## サンプルプログラム
**リストA** では、あらかじめ「int pipe_fd[2]」という配列を用意してから`pipe`を呼び出しています。
この後`fork`で子プロセスを作成して、子プロセスからパイプの書き込み側に`write`でメッセージを書き込んでいます。
親プロセスではパイプの読み出し側から`read`でデータを読んでおり、これにより子プロセスからのメッセージが親プロセスに伝わります。

この例では、子プロセスはパイプの書き込み側（`pipe_fd[1]`）のみを使用し、パイプの読み出し側（`pipe_fd[0]`）は必要ないため、`fork`のあとに`close`しています。
同様に、親プロセスのパイプの書き込み側（`pipe_fd[1]`）もforkの後に`close`します。

なお、サンプルプログラムではパイプのファイル記述子をそのまま使って`read`/`write`を行っていますが、
シェルなどでコマンドの標準入出力にパイプを接続する場合は、`pipe`と`fork`を実行した後、`dup`/`dup2`または`fcntl`を使って、
パイプのファイル記述子を`0`（標準入力）または`1`（標準出力）のファイル記述子に複製します。
この状態でコマンドを`execve`すれば、そのコマンドの標準入力または標準出力がパイプに接続されます。

**リストA** `pipe`で子プロセスから親プロセスへデータを送る
```c
#include <unistd.h> // for pipe()
#include <stdio.h> // for perror()

int main() {
    int pipe_fd[2];
    pid_t child_pid;

    // readの文字数を受け取るための変数
    ssize_t n;
    // read用文字列のバッファ
    char buf[4096];

    // パイプを作成
    if (pipe(pipe_fd) < 0) {
        perror("pipe");
        return 1;
    }

    // 子プロセスを作成
    if ((child_pid = fork()) < 0) {
        perror("fork");
        return 1;

    /* 子プロセス側 */
    } else if (child_pid == 0) {
        // パイプの読み出し側は不要
        close(pipe_fd[0]);

        // パイプにメッセージを書き込む
        write(pipe_fd[1], "Hello\n", 6);

        // 戻り値0で子プロセスを正常終了
        _exit(0);
    }


    /* 親プロセス側 */    

    // パイプの書き込み側は不要
    close(pipe_fd[1]);

    // パイプから読み込む
    if ((n = read(pipe_fd[0], buf, sizeof buf)) < 0) {
        perror("read");
        return 1;
    }

    // 読み込んだメッセージを標準出力に出力
    write(1, buf, n);

    return 0;
}
```

**実行結果**
```
$ ./pipe
Hello
```
